---
layout: post
title:  "Heap Sort"
date:   2020-05-16
tags: Sorting Tree Heap
mathjax: true
---

Heap sort is very important content.

[Table of Content](2020-05-16-Heap-Sort.md)
- [1. Binary Heap - Data Structure](#1-binary-heap---data-structure)
- [2. Maintaining the Heap Property (Max-Heap)](#2-maintaining-the-heap-property-max-heap)

### 1. Binary Heap - Data Structure
A binary heap is a specialized *binary tree-based* data structure which is essentially an ***almost complete tree*** that satisfies the binary heap property. There are two types of binary heaps, max-heaps and min-heaps.
> A **Complete Tree** is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible. A complete tree must be a balanced tree.
> 
> **Max Heap Property**: for every node $i$, other than the root, $A[Parent(i)] \geq A[i]$, that is, the value of a node is at most the value of its parent. Thus, the largest element in a max-heap is stored at the root, and the subtree rooted at a node contains values no larger than that contained at the node itself.
>
> **Min Heap Property**: Conversely, for every node $i$ other than the root, $A[Parent(i)] \leq A[i]$. The smallest element in a min-heap is at the root.

Due to its complete tree property, each node of the tree corresponds to an element of the array. Thus, We have the following conversion between array index and heap.
{% highlight java linenos %}
// i is the index in the array
PARENT(i):
  return floor(i/2)
LEFT(i):
  return 2*i
RIGHT(i):
  return 2*i+1
{% endhighlight %}

A more detailed example can be seen in the figure below.
<figure>
    <img src="https://zl323.github.io/assets/postImg/maxheap.png" alt="useful image" height="100%" width="100%">
    <figcaption>Credit to Introduction to Algorithm by Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein</figcaption>
</figure>

> Viewing a heap as tree, we define the height of a node in a heap to be number of edges on the longest simple downward path from the node to a leaf, and we define the height of the heap to be the height of its root. Since a heap of n elements is based on complete tree, its height is $\lfloor{logn}\rfloor$.

### 2. Maintaining the Heap Property (Max-Heap)
To preserve the heap property, we need to do MAX_HEAPIFY everytime we insert additional node into the heap. Here is the pseudocode for MAX_HEAPIFY: 

{% highlight java linenos %}
MAX_HEAPIFY(A, i):
  largest = i
  l = LEFT(i)
  r = RIGHT(i)
  // compare left and right child with parent and see which one is the largest
  if(l <= heapSize and A[l] > A[largest]) 
    largest = l
  if(r <= heapSize and A[r] > A[largest])
    largest = r
  // if the largest lies in left/right child, swap it with the parent node
  // continue doing recursion
  if(largest != i)
    swap(A, i, largest)
    MAX_HEAPIFY(A, largest)
{% endhighlight %}

Let's analyze the runtime of MAX_HEAPIFY method. Comparison among A[LEFT(i)], A[RIGHT(i)] and PARENT A[i] takes $O(1)$. The recursion cost in the MAX_HEAPIFY depends on the height of the binary tree. In the worst case, the children’s subtrees each have size at most 2n/3—the worst case occurs when the bottom level of the tree is exactly half full.

***Think: Why does the worst case happen when the bottom level of the tree is exactly half full? Where does 2n/3 come from?***
<details>
<summary>answer</summary>
<figure>
    <img src="https://zl323.github.io/assets/postImg/CompleteBinaryTree.png" alt="useful image" height="45%" width="45%">
    <figcaption>A Basic Complete Binary Tree</figcaption>
</figure>
As we can see from the figure above, when the bottom level of the tree is exactly half full, the children’s subtrees each have size at most 2n/3. The left subtree determines the runtime. Also, as we discussed in the 1st section, a complete tree must be a balanced tree. Therefore, the height difference of left and right subtrees cannot exceed 1.
</details>

Therefore, the runtime cost by recursion in MAX_HEAPIFY is:
\\[
T(n) <= T(2n/3) + T(1)
\\]
We can conclude that $T(n) = O(logn)$, or $O(h)$, where $h$ is the height of tree, which is the overall runtime of MAX_HEAPIFY.